BTChip : Technical Specification  
=================================
BTChip <contact@btchip.com>
firmware version 1.4.2

== Changelog from 1.4.0
  - [enh] ECC operations speed-up
  - [bug] Private key are now paired to their curve parameters (cheers Jix :p)

== Changelog from 1.4.1
  - [enh] New security rules & operation modes

== About

BTChip is a USB smartcard/dongle dedicated to secure bitcoin transactions. It performs all sensitive cryptographic operations related to a bitcoin transaction (key generation & signature) onboard, and helps protect against malware in an untrusted environment by controlling the signed data.

== Operation modes

Operation modes define which operations are allowed given the security environment the dongle is operating in.

Two operation modes are defined, from the less restrictive to the more restrictive : 

  - Trusted : This mode should be reserved to known trusted environments.

  - Untrusted : This mode is the default mode when using standard operation parameters. 

The operation mode is persistent. 

The user is always authorized to move from an operation mode to a more restrictive operation mode. However an authentication is required to move to a less restrictive operation mode.  

=== Trusted operation mode

All dongle functionalities are enabled in trusted mode. Arbitrary data can be signed by the dongle.

=== Untrusted operation mode

==== Overview


Only point-to-point outputs (i.e. the standard script) sent to authorized bitcoin addresses can be signed automatically. Complex scripts can be signed with a specific per script cryptographic authorization.

The standard script is coded as 

---------------------------------------------------------------------------------
OP_DUP OP_HASH160 [pubKeyHash] OP_EQUALVERIFY OP_CHECKSIG
---------------------------------------------------------------------------------

An authorized bitcoin address is a regular bitcoin address authorized by the user, then encrypted.

Transaction amounts are not secured on a fine grained level per transaction, other than supporting a pre registered maximum value - it is admitted that setting smaller random transaction amounts for a malware has a limited interest, other than making miners happier or just messing around, which is usually not a strong motive for nowadays malware industry.

In a similar way, the input sequence number and transaction lock time are not secured on a fine grained level either. It is admitted than point-to-point payment is more common than other contracts nowadays.

A cryptographic authorization can be computed offline to sign an arbitrary script, based on the hash of the script that is to be signed, and/or provide a transaction amount limit greater than the generic one. Authorizations are protected against replay through a sequence counter - once an authorization has been accepted, the next authorization must be presented with a sequence counter greater than the previous one. Once the sequence counter reaches its maximum value 0xffffffff, it is reset to 1.

In order to authorize a public key address on the fly, a challenge/response mechanism is set up when the dongle is received and personalized by the user.

Challenges are defined by the user using a minimalistic script language called the Challenge engine - given random parameters and a user provided description which should identify in a unique way what the script is doing, the user validates elements of the address and returns a response as a set of numbers from 0 to 9.  

Challenges keep the user protected because the script logic is unknown, providing it is well customized with a description that can not be trivially parsed by the malware, and responses are difficult to tell apart.

As an additional protection from man in the middle and remote human attacks, a minimum time and maximum time in seconds can be defined for all challenge scripts. If a response is received before the minimum time, or after the maximum time, the challenge round is always failed. The reponse timer starts running when the challenge is sent.

When a given number of challenge rounds are performed successfuly, the authorized address is returned by the dongle. After a configurable number of wrong responses, the dongle is locked-up until removed from the USB port and reinserted, and the import functionality is disabled until reenabled in a trusted environment

Other dongle functionalities are disabled in untrusted mode : 

   - Authentication with a GlobalPlatform keyset other than 0x10 or 0xFE is disabled - to prevent accidental data leaks in an untrusted environment
   - CREATE FILE is disabled - to prevent a malware from creating arbitrary transaction control rules if an accidental key leak occured by authenticating with keyset 0x10 in an untrusted environment
   - All bitcoin APDUs are forbidden following a GET SERIAL NUMBER or an INITIALIZE UPDATE without EXTERNAL AUTHENTICATE - to prevent malware running on a public computer to keep a list of challenges associated to dongle serial numbers

==== Challenge engine
[[challengeengine]]

The challenge engine defines opcodes operating on 100 random input parameters P. Each parameter is a number between 2 and the length of the address being validated.

Opcodes are chained together to create a sequence of 0-9 numeric responses that the user must submit. Most opcodes are associated to a parameter X, which defines an offset into the address as P[X]

The following opcodes are available : 

   - IS NUMERIC(X) : expects TRUE if the given address character is numeric, or FALSE
   - IS NUMERIC ODD(X) : expects TRUE if the given address character is an odd number, or FALSE (if not odd or not a number)
   - IS NUMERIC EVEN(X) : expects TRUE if the given address character is an even number, or FALSE (if not even or not a number)
   - IS ALPHA UPPERCASE(X) : expects TRUE if the given address character is an uppercase alphanumeric character, or FALSE (if a number or lowercase)
   - IS ALPHA LOWERCASE(X) : expects TRUE if the given address character is a lowercase alphanumeric character, or FALSE (if a number or uppercase)
   - SKIP : does not perform any validation on this response and move to the next
   - GET CHARACTER(X) : returns the character as a Base 58 index module 10. The following conversion 
   table is applied 

---------------------------------------------------------------------------------
   Character :       123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
   Expected output : 0123456789012345678901234567890123456789012345678901234567
---------------------------------------------------------------------------------   

TRUE is defined along with the Challenge engine scripts - it can be :

    - A number greater than a given parameter
    - A number smaller than a given parameter
    - An odd number
    - An even number

An input that does not validate as TRUE is FALSE  

Each script can use at most 20 opcodes, not including SKIP opcodes.

== Additional key types 

The following key types are added 

   - 20 : Private key encryption - these keys are used to encrypt private keys (trusted/untrusted)
   - 21 : Secure hash encryption - these keys are used to encrypt secure hashes (untrusted)
   - 22 : Authorized address encryption - these keys are used to encrypt authorized addresses (untrusted)
   - 23 : Special output authorization encryption - these keys are used to encrypt special output authorizations (untrusted)
   - 24 : Trusted GlobalPlatform - commands sent over a Secure Channel opened by such keyset will be executed
   in trusted mode, if at least command confidentiality (CMAC) is activated for this Secure Channel.

The first Key Access parameters byte is coded as per the other keys, and the second byte is not used.

== Additional files 

=== Elliptic curve parameters

Elliptic curve parameters are stored in transparent files in 3F00/CE15 DF, using the following format

[width="80%"]
|==============================================================================================================================
| *Bytes*            | *Description*                                              | *Length*
|                    | Size of A component                                        | 1
|                    | A component                                                | 
|                    | Size of B component                                        | 1
|                    | B component                                                | 
|                    | Size of Field component                                    | 1
|                    | Field component                                            | 
|                    | Size of G component                                        | 1
|                    | G component                                                | 
|                    | Size of R component                                        | 1
|                    | R component                                                | 
|                    | Size of K component                                        | 1
|                    | K component                                                | 
|==============================================================================================================================

The secp256k1 bitcoin curve is provided in the 0xb1c0 file, and cannot be updated by the user.

Access conditions for the 0xb1c0 file are : 

    - READ         ALWays
    - UPDATE       0xFE (administrative keyset)
    - DELETE       0xFE (administrative keyset)


=== Operation parameters

Operation parameters are defined in the 0xb101 file located in 0x3f00. They define the basic functionalities of the dongle

[width="80%"]
|==============================================================================================================================
| *Bytes*            | *Description*                                              | *Length*
| 1                  | Current operation mode        

                            0x01 : trusted

                            0x02 : untrusted (default)
                                                                                  | 1
| 2                  | Number of challenge rounds in authorized address import. 
                       If set (different from 0x00), cannot be lower than 0x02.

                       Initially set to 0x04
                                                                                  | 1 
| 3                  | Maximum number of consecutive wrong challenge responses 
                       before disabling authorized address import. Import 
                       functionality is disabled if set to 0x00

                       Initially set to 0x03                                      | 1
| 4-7                | Current specific authorization counter (little endian). 
                       Counter validation is disabled if set to 0x00         

                       Initially set to 0x01 
                                                                                  | 4                     
| 8-11               | Restriction ack returned by the dongle when
                       switching to a more restrictive mode

                       Initially set to RTFM                                      | 4
|==============================================================================================================================


Access conditions for this file are : 

    - READ         0x01 (default user keyset)
    - UPDATE       0x01 (default user keyset)
    - DELETE       0xFE (administration keyset)

=== Transaction control

Transaction control parameters are stored in transparent files in 3F00/0D11 DF, and are used to set generic rules for controlling transactions, using the following format

[width="80%"]
|==============================================================================================================================
| *Bytes*            | *Description*                                              | *Length*
| 1                  | Flags (RFU)                                                | 1
| 2-8                | Maximum amount or allowed per output, little endian        | 8
| 9-12               | Minimum sequence index (apply to all inputs), little endian| 4
| 13-16              | Maximum sequence index (apply to all inputs), little endian| 4
| 17-20              | Minimum lock time, little endian                           | 4
| 21-24              | Maximum lock time, little endian                           | 4
| 25                 | Bitmask of authorized SigHash values  

                            0x01 : SIGHASH_ALL authorized

                            0x02 : SIGHASH_NONE authorized

                            0x04 : SIGHASH_SINGLE authorized                       

                            0x08 : mask SIGHASH_ANYONECANPAY authorized           | 1
|==============================================================================================================================


A default configuration file for payments up to 1 BTC is provided in the 0x0001 file, and cannot be updated by the user, using the following values :

   - Maximum amount allowed per output : 00 10 5E 5F 00 00 00 00 (1.000000000)
   - Minimum sequence index : FF FF FF FF
   - Maximum sequence index : FF FF FF FF
   - Minimum lock time : 00 00 00 00
   - Maximum lock time : 00 00 00 00
   - Bitmask of authorized SigHash values : 0x01

Access conditions for the 0x0001 file are : 

    - READ         ALWays
    - UPDATE       0xFE (administrative keyset)
    - DELETE       0xFE (administrative keyset)

The maximum amount specified in a transaction control can be overriden for a specific output by providing a Special Output authorization structure when hashing the output.

=== Challenge engine data

Challenge engine data are stored in transparent files in 3F00/B1CA DF

[width="80%"]
|==============================================================================================================================
| *Bytes*            | *Description*                                              | *Length*
| 1                  | Flags (RFU)                                                | 1
| 2                  | Meaning of  TRUE :       

                           01 : number greater than parameter

                           02 : number smaller than parameter

                           03 : odd number

                           04 : even number
                                                                                      | 1
| 3                  | Parameter for TRUE, if 01/02, or not used                      | 1
| 4                  | Length of the 1st script description, that will be provided
                       to the user to run the challenge (max 150 chars)               | 1
| 5                  | 1st script description                                         | var
| 6                  | Minimum time in seconds, or 0                                  | 1
| 7                  | Maximum time in seconds, or 0                                  | 1
|                    | Length of the 1st challenge script (max 100 bytes)             | 1                       
|                    | 1st challenge script                                           | var
|                    | Length of the 2nd script description                           | 1
|                    | 2nd script description                                         | var
|                    | Minimum time in seconds, or 0                                  | 1
|                    | Maximum time in seconds, or 0                                  | 1
|                    | Length of the 2nd challenge script                             | 1
|                    | 2nd challenge script                                           | var
|==============================================================================================================================

Challenge scripts are coded as a sequence of opcodes. Each opcode is coded as 2 bytes, the first byte being the opcode, the second one the parameter associated to the opcode. The parameter has no meaning for the SKIP opcode.

[width="80%"]
|==============================================================================================================================
| *Opcode*           | *Coding*                                             
| IS NUMERIC         | 0x01
| IS NUMERIC ODD     | 0x02
| IS NUMERIC EVEN    | 0x03
| IS ALPHA UPPERCASE | 0x04
| IS ALPHA LOWERCASE | 0x05
| GET CHARACTER      | 0x06
| SKIP               | 0x90
|==============================================================================================================================

Challenge engine files permissions are set by the user. They must of course never be world readable or updateable. Read access conditions are ignored during signature operations.

== Trusted and untrusted operation mode APDUs

=== SET OPERATION MODE

==== Description

This command is used to set the operation mode of the dongle.

Going to a more restrictive operation mode is always authorized. The restriction ack defined in the operation parameters will be sent back, as a way to check that the command has not been intercepted when operating on a new untrusted platform.

If going to a less restrictive operation mode, the user shall be authenticated by the GlobalPlatform user key 0x10. 

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*               | *P2*       | *Lc*     | *Le*   
|   E0  |   24   |  target mode or 00 to query the current operation mode      |   00 : persistent change

                                          80 : non persistent change done until powered down (only if going to a less restrictive mode)       |   00     |   00
|==============================================================================================================================


'Input data'

None

'Output data (when querying the operation mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                     | *Length*
| 1          | Current operation mode                                                            | 1
|==============================================================================================================================

'Output data (when going to a more restrictive operation mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                     | *Length*
| 1          | Restriction ack as defined in operation parameters                                | 4
|==============================================================================================================================

'Output data (when going to a less restrictive mode)'

None

'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================


=== GENERATE KEYPAIR OR IMPORT PRIVATE KEY

==== Description

This command is used to generate a keypair using the given curve parameters or import a given private key.

The file containing the curve parameter shall be selected before calling this command when generating a keypair.

The private part of the keypair will be encrypted by the Private key encryption key version passed as input parameter.
This key must be accessible when the function is called

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*        | *P2*       | *Lc*     | *Le*   
|   E0  |   20   |   00 : generate mode

                     01 : generate mode and provide Authorized Address for public key

                     80 : prepare mode       |   00 |   var    |   var
|==============================================================================================================================


'Input data (generate mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
| 1          | Version of the private key encryption to use                           | 1
| 2          | Keypair flags                                              

                          01 : key can only be used in trusted mode                   | 1
| 3-4        | File ID of the curve to use to generate this key                       | 2
| 5          | If requesting an Authorized Address, Authorized Address Encryption keyset version to use   | 1
| 6          | if requesting an Authorized Address, Bitcoin address version                    | 1
|==============================================================================================================================

'Input data (prepare mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                              | *Length*
| 1          | Version of the private key encryption to use                               | 1
| 2          | Keypair flags                                              

                          01 : key can only be used in trusted mode                       | 1
| 3-4        | File ID of the curve to use to generate this key                       | 2
| 5          | private key to encode                                                      |
|==============================================================================================================================


'Output data (generate mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                       | *Length*
| 1          | Length of public key component (*41*)                                               | 1
|            | Public key component (W)                                                            | p
|            | Length of encrypted private key component (*28*)                                    | 1
|            | Encrypted private key component (encrypted S)                                       | P
|            | If generating an Authorized Address, length of the 
               Authorized Address (*20*)                                                           | 1
|            | If generating an Authorized Address, Authorized address                             | 20

|==============================================================================================================================

'Output data (prepare mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
| 1          | Encrypted private key component (encrypted S)                                   | 

|==============================================================================================================================


'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================


=== AUTHORIZE ADDRESS

==== Description

This command is used to encode an address authorization.

The address is an hash160 (ripemd160 of a sha256) of an ECDSA public key, encoded using base58.

The authorized address will be encrypted by the Authorized address encryption version passed as input parameter.

This key must be accessible when the function is called

When running in untrusted mode, a challenge round might be required before authorizing the address. In this case, specific output data will be sent to describe the challenge, which should be answered to obtain the authorized address.

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*        | *P2*       | *Lc*     | *Le*   
|   E0  |   22   |   00 : authorize address

                     80 : send challenge response       |   00       |   var    | var   
|==============================================================================================================================


'Input data (no challenge ongoing)'

[width="80%"] 
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                                   | *Length*
| 1          | Version of the Authorized address encryption key to use                           | 1
| 4          | Base58 encoded address size                                                       | 1
| 5-         | Base58 encoded address to authorize                                               | var
|            | File ID containing the challenge engine data to use 
               (not used if operating in secure mode)                                            | 2
|==============================================================================================================================

'Input data (challenge ongoing)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                                   | *Length*
| 1          | Version of the Authorized address encryption key to use                           | 1
| 2          | Base58 encoded address size                                                       | 1
| 3-         | Base58 encoded address to authorize                                               | var
|            | Challenge response                                                                | var
|==============================================================================================================================


'Output data (no challenge round)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                                   | *Length*
|  1         | Challenge Status : No Challenge (*00*)                                             | 1
|            | Authorized address                                                                 | 20
|==============================================================================================================================

'Output data (challenge round)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                                   | *Length*
|  1         | Challenge Status : Challenge required (*80*)                                      | 1
|  2         | Challenge description size                                                        | 1
|            | Challenge description                                                             | var
|            | Challenge input data                                                              | 64
|==============================================================================================================================

'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================


== Trusted operation mode APDUs

=== ECDSA SIGN/VERIFY IMMEDIATE

==== Description

This command is used to sign a given hash using a private key or verify a given signature using a public key

The private key shall be encrypted by the Private key encryption key version passed as input parameter.
This key must be accessible when the function is called

If a signature is required in untrusted mode, this command will exit with status word 0x6982

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*        | *P2*       | *Lc*     | *Le*   
|   E0  |   40   |   00 : sign

                     80 : verify        |   00       |  var     |   var
|==============================================================================================================================


'Input data (sign mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                       | *Length*
| 1          | Version of the private key encryption to use                                        | 1
| 2          | Length of encrypted private key                                                     | 1
| 3          | Encrypted private key                                                               |
|            | Hash to sign                                                                        |
|==============================================================================================================================

'Input data (verify mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
| 1          | Length of public key                                                            | 1
| 2          | Public key                                                                      |
|            | Length of hash to verify (up to 32 bytes)                                       |
|            | Hash to verify                                                                  |
|            | Signature                                                                       |
|==============================================================================================================================


'Output data (sign mode)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                  | *Length*
|            | Signed hash, as ASN-1 encoded R & S components                                 | 
|==============================================================================================================================

'Output data (verify mode)'

None


'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (running in untrusted mode)
|   6A80   | Invalid data (invalid key encryption)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================


== Untrusted operation mode APDUs

=== UNTRUSTED HASH TRANSACTION

==== Description

This command is used to compose an opaque SHA-256 hash for a new transaction, controlled by the given transaction control file.

The newly returned hash component will be encrypted by the Secure hash encryption key. This key must be accessible when the function is called.

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*        | *P2*       | *Lc*     | *Le*   
|   E0  |   42   |  00         |  00        | var      | var   
|==============================================================================================================================

'Input data'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                                   | *Length*
| 1-2          | File ID of the transaction control file to use for generic rules regarding this
                 transaction                                                                      | 2
| 3-6          | Version                                                                          | 4
| 7            | Number of inputs as a VarInt, limited to 32 bits coding                          | var
|              | Number of outputs as a VarInt, limited to 32 bits coding
|==============================================================================================================================

'Output data'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                    | *Length*
|            | Encrypted hash component                                                         | var

|==============================================================================================================================

'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================


=== UNTRUSTED HASH INPUT

==== Description

This command is used to compose an opaque SHA-256 hash for a new transaction input.

Each provided input is supposed to be prepared for the signature to perform - only the currently indexed input
should have a non null connected output script.

The data provided by the host will be checked against the following structure. Field of the structure cannot be split over different messages unless specific otherwise :

   - Varint number of inputs, 64 bits varints being rejected
   - 32 bytes arbitrary data (outpoint hash)
   - 4 bytes arbitrary data (outpoint index)
   - Varint size of script, 64 bits varints being rejected, coding the length of the connected output script L
   - L bytes arbitrary data (connected output script). This field can be split over different messages
   - 4 bytes sequence. This value will be enforced by the transaction control file in use for this transaction   

The hash component will be decrypted/encrypted by the Secure hash encryption key. This key must be accessible when the function is called.

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*        | *P2*       | *Lc*     | *Le*   
|   E0  |   44   |  00         |   00       |   var    | var   
|==============================================================================================================================


'Input data'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                        | *Length*
| 1          | Secure hash encryption key version                                                   | 1
| 2          | Length of the encrypted hash component to update                                     | 1
|            | Encrypted hash component to update                                                   | var
|            | Data to hash                                                                         |
|==============================================================================================================================


'Output data'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
|            | Encrypted hash component                                                        | var 

|==============================================================================================================================

'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================

=== UNTRUSTED HASH DIRECT OUTPUT

==== Description

This command is used to compose an opaque SHA-256 hash for a transaction output attached to an input.

This command is rejected if all inputs advertised at the beginning of the transaction have not been processed first.

The generated script will be the standard script coded as below given the Authorized address.

---------------------------------------------------------------------------------
OP_DUP OP_HASH160 [pubKeyHash] OP_EQUALVERIFY OP_CHECKSIG
---------------------------------------------------------------------------------

The amount will be enforced given the transaction control file used for this transaction

The hash component will be decrypted/encrypted by the Secure hash encryption key. This key must be accessible when the function is called.

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*        | *P2*       | *Lc*     | *Le*   
|   E0  |   46   | 00 : no special authorization provided
          
                   other value : special authorization keyset reference
                               |   00       |   var    | var   
|==============================================================================================================================


'Input data'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                       | *Length*
| 1          | Secure hash encryption key version                                                  | 1
| 2          | Length of the hash component to update                                              | 1
|            | Encrypted hash component to update                                                  | var
|            | Length of the special authorization to apply or 00                                  | 1
|            | Encoded special authorization                                                       | 28
|            | Authorized Address to use                                                           | 20
|            | Amount                                                                              | 8
|==============================================================================================================================


'Output data'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
|            | Encrypted hash component                                                        | var
|==============================================================================================================================

'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================


=== UNTRUSTED HASH COMPLEX OUTPUT

==== Description

This command is used to compose an opaque SHA-256 hash for a transaction output with a non standard script attached to an input.

This command is rejected if all inputs advertised at the beginning of the transaction have not been processed first.

The data provided by the host will be checked against the following structure. Field of the structure cannot be split over different messages unless specific otherwise :

   - 8 bytes amount. This value will be enforced by the special authorization
   - Varint size of script, 64 bits varints being rejected, coding the length of the output script L
   - L bytes arbitrary data (output script). This field can be split over different messages. The hash of the script will be enforced by the special authorization.

The hash component will be decrypted/encrypted by the Secure hash encryption key. This key must be accessible when the function is called.

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*        | *P2*       | *Lc*     | *Le*   
|   E0  |   48   |  01 : first block

                    80 : last block
         |   00       |   var    | var   
|==============================================================================================================================


'Input data (first block)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                        | *Length*
|            | Special authorization encryption key version                                         | 1
|            | Encoded Special authorization                                                        | 28
|==============================================================================================================================

'Input data (next blocks)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                            | *Length*
| 1          | Secure hash encryption key version                                                   | 1
| 2          | Length of the hash component to update for the transaction                           | 1
|            | Encrypted hash component for the tranasction to update                               | var
|            | Length of the hash component to update for the script control                        | 1
|            | Encrypted hash component for the script control to update                            | var
|            | Data to hash                                                                         |
|==============================================================================================================================

'Output data (first block)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
|            | Encrypted hash component for the script control                                 | var
|==============================================================================================================================

'Output data (not the last block)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
|            | Length of the encrypted hash component for the transaction                      | 1
|            | Encrypted hash component for the transaction                                    | var
|            | Length of the encrypted hash component for the script control                   | 1
|            | Encrypted hash component for the script control                                 | var
|==============================================================================================================================

'Output data (last block)'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
|            | Encrypted hash component for the transaction                                    | var
|==============================================================================================================================

'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================


=== SIGN UNTRUSTED HASH

==== Description

This command is used to sign a given secure hash using a private key (after re-hashing it following the standard Bitcoin signing process) to finalize a transaction input hash.

This command will be rejected if all outputs advertised for this transaction have not been processed.

The private key shall be encrypted by the Private key encryption key version passed as input parameter.
This key must be accessible when the function is called

The locktime and SigHash value will be enforced given the transaction control file used for this transaction

The hash component will be decrypted by the Secure hash encryption key. This key must be accessible when the function is called.

==== Coding

'Command'

[width="80%"]
|==============================================================================================================================
| *CLA* | *INS*  | *P1*        | *P2*       | *Lc*     | *Le*   
|   E0  |   4A   |   00        |   00       |  var     |   var
|==============================================================================================================================


'Input data'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                      | *Length*
| 1          | Version of the private key encryption to use                                       | 1
| 2          | Secure hash encryption key version                                                 | 1
| 3          | Length of encrypted private key                                                    | 1
| 4          | Encrypted private key                                                              |
| 5          | Length of the Secure Hash to sign                                                  | 1
| 6          | Encrypted hash component to sign                                                   | var
|            | Lock Time                                                                          | 4
|            | SigHash                                                                            | 1
|==============================================================================================================================


'Output data'

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                   | *Length*
|            | Signed hash, as ASN-1 encoded R & S components                                  | 
|==============================================================================================================================

'Licensing'

This function is always available

'Status Words'

[width="80%"]
|===============================================================================================
| *SW*     | *Description*
|   6581   | Memory problem
|   6700   | Incorrect length
|   6982   | Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
|   6A82   | File not found
|   6B00   | Incorrect parameter P1 or P2
|   6Fxx   | Technical problem (00 : no diagnostic given)
|   9000   | Normal ending of the command
|   9804   | Access condition not fulfilled
|================================================================================================

== Data structures

The format of the data structures is provided for interoperability and validation purposes. A typical user will not need to manipulate them directly.

=== Encoded private key for a 256 bits curve

An encoded private key is stored internally as follow, Triple DES encrypted by the private key encryption key

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                        | *Length*
| 1          | Magic version (*01*)                                                                 | 1
| 2          | Private key flags (RFU)                                                              | 1
| 3-4        | ID of the file in 3F00/CE15 containing the curve parameters                          | 2
| 5-6        | CRC-16 of the structure computed after setting current bytes to 0000                 | 2
| 7-8        | Nonce                                                                                | 2
| 9          | Private key component (S)                                                            | 20
|==============================================================================================================================

=== Encoded authorized address

An encoded authorized address is stored internally as follow, Triple DES encrypted by the authorized address encryption key

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                        | *Length*
| 1          | Magic version (*21*)                                                                 | 1
| 2          | Public key flags           
                       
                       0x01 : internally generated change address. Control rule amount restriction
                       will not apply
                                                                                                    | 1
| 3-4        | CRC-16 of the structure computed after setting current bytes to 0000                 | 2
| 5-10       | Nonce                                                                                | 7
| 11         | Bitcoin address version                                                              | 1
| 12         | Bitcoin address as a hash160                                                         | 14
|==============================================================================================================================

=== Encoded secure hash

An encoded secure hash is stored internally as follow, Triple DES encrypted by the secure hash encryption key

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                        | *Length*
| 1          | Magic version (*41*)                                                                 | 1
| 2-3        | CRC-16 of the structure computed after setting current bytes to 0000                 | 2
| 4-9        | Nonce                                                                                | 2
| 10-41      | Accumulator                                                                          | 20
| 42-44      | Block count                                                                          | 2
| 45-46      | Pending data block length                                                            | 1
| 47-        | Pending data block                                                                   | var
|            | Padding nonce                                                                        | 0-var
|==============================================================================================================================

=== Encoded special output authorization

An encoded special output authorization is stored internally as follow, Triple DES encrypted by the special output authorization encryption key

[width="80%"]
|==============================================================================================================================
| *Byte(s)*  | *Description*                                                                        | *Length*
| 1          | Magic version (*61*)                                                                 | 1
| 2-3        | CRC-16 of the structure computed after setting current bytes to 0000                 | 2
| 4-11       | Nonce                                                                                | 4
| 12         | Flags    

                    0x01 : Address authorization - authorize the provided amount for the given
                         output address in a standard script. 

                    0x02 : Script authorization - authorize the provided amount for the given
                         script hash, computed as RIPEMD160(SHA256(scriptBytes))
                                                                                                    | 1
| 13-20       | Amount to authorize                                                                 | 8
| 21-40       | Address or script hash to authorize                                                 | 14
| 41-44       | Sequence counter                                                                    | 4 
|==============================================================================================================================

== Security risks and countermeasures 

=== Local attack forcing an arbitrary transaction to an arbitrary address

This scenario is always prevented when the dongle operates in untrusted mode

=== Local attack forcing a transaction with an arbitrary amount to an authorized address 

This attack is limited to an arbitrary amount validating a transaction control rule defined by the dongle owner before the transaction

=== Local attack replaying a specific output authorization

This attack is prevented by the sequence counter given in the authorization

=== Local attack modifying all displayed bitcoin addresses to addresses owned by the attacker

3) profit ? if the user reads addresses from a compromised computer before paying :p

== Samples 

=== Sample challenge round 

A simple challenge script is defined as follows :

  - TRUE is greater than 5
  - Script description : "Read the universal number, is neighbour a digit ?"
  - Script opcodes : GET CHARACTER 42, IS NUMERIC 43

The challenged address is 18HrWgHbp45W63WSiHoUVaEQXAXAhkHsaG

On the first challenge round, the dongle generates 100 random input parameters. For this example, let's assume than from index 40 to 43 the parameters are : 12 30 9 14

The user script is parsed by the dongle as follows :
  
  - GET CHARACTER 42 is interpreted as "Get character address at index 9". Address character 9 is p, which is converted to 7 using the base58 conversion table provided in the <<challengeengine, Challenge Engine description>>.

---------------------------------------------------------------------------------
   Character :       123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
   Expected output : 0123456789012345678901234567890123456789012345678901234567
---------------------------------------------------------------------------------   

  - IS NUMERIC 43 is interpreted as "Is character address 14 numeric ?". Address character 14 is 3, which is TRUE. Let's assume that the user answers 8, which is valid for TRUE with the given conditions.

A valid response to this round will be 78. Other random characters can be appended for good fun.
